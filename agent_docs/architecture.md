# Architecture

> **For agents:** This file is loaded only when a task involves design decisions or cross-cutting changes.
>
> **Your task:** Understand how the system is structured, how data flows, what the key design decisions are, and what the boundaries are. The structure below shows what to document. The examples are from a Next.js/TypeScript/Prisma project — replace them with THIS project's actual architecture.

## System Overview

> **What to discover:** What type of application is this? What are the main components? How is it deployed? What are the main use cases or surfaces?

**Current example (REPLACE THIS):**

Monolithic Next.js 15 app using the App Router. PostgreSQL via Prisma for persistence. NextAuth for authentication. Deployed on Vercel with preview deploys on every PR.

The app has three main surfaces:
- **Public marketing pages** — static, ISR-rebuilt nightly
- **Authenticated dashboard** — dynamic, server-rendered per-request
- **API layer** — Next.js route handlers under `src/app/api/`

## Data Flow

> **What to discover:** How does data move through the system? Where does it enter? How is it validated? Where is it persisted? How do different layers communicate?

**Current example (REPLACE THIS):**

```
Browser → Next.js App Router → Route Handler → Prisma Client → PostgreSQL
                                    ↓
                              Zod validation at entry
                              Result<T,E> return types
                              No raw SQL — Prisma queries only
```

Server components fetch data directly via Prisma helpers in `src/lib/db/`. Client components call API routes through `src/lib/api-client.ts`, which wraps fetch with auth headers and error normalization.

## Key Decisions

> **What to discover:** What are the significant architectural choices? Why were they made? What tradeoffs were accepted? Look for README sections, architecture docs, or ask about past discussions.
>
> Format: Bold decision statement, then 1-2 sentence explanation with rationale.

**Current examples (REPLACE THESE):**

- **Server components by default.** Client components only for interactivity (forms, modals, real-time). Every `'use client'` should have a clear reason.
- **Zustand over Redux.** One store per domain concept (`src/stores/`). No global god-store. Server state stays server-side; Zustand is for UI state only.
- **Result types over exceptions.** Functions that can fail return `{ok: true, data}` or `{ok: false, error}`. See `src/lib/errors.ts`. This makes error paths explicit at call sites.
- **Colocation.** Tests live next to source files (`__tests__/` subdirectories). Page-specific components live in their route directory, not in the shared `components/` folder.

## Boundaries

> **What to discover:** What directories or files should never be hand-edited? Where are environment variables defined? What code should only be accessed through specific interfaces?

**Current examples (REPLACE THESE):**

- **`src/generated/`** — Auto-generated by Prisma. Never hand-edit. Run `prisma generate` after schema changes.
- **`src/config.ts`** — Single source for all env vars. Validated at startup with Zod. Components and lib code import from here, never from `process.env`.
- **`src/lib/db/`** — Only place Prisma client is used. Route handlers and server components call functions from here, not Prisma directly. This keeps the query surface auditable.

## External Dependencies

> **What to discover:** What third-party services does this project integrate with? How are they configured? What do you need to know to work with them in development?

**Current examples (REPLACE THESE):**

- **Stripe** — Payment processing. Webhook handler at `src/app/api/webhooks/stripe/route.ts`. Test with `stripe listen --forward-to localhost:3000/api/webhooks/stripe`.
- **Cloudinary** — Image uploads and transforms. Helper at `src/lib/cloudinary.ts`. Dev uses the sandbox account (keys in `.env.local`).
- **Resend** — Transactional email. Templates in `src/lib/email/templates/`. Dev sends to Ethereal (fake SMTP).
